# Cursor Rules for FlashyCardyCourse

## ğŸš¨ CRITICAL SECURITY REQUIREMENT
**ALL AUTHENTICATION IS HANDLED BY CLERK. USERS MUST ONLY ACCESS THEIR OWN DATA.**

## Rule Organization

This project uses organized development rules stored in `.cursor/rules/`. Each file focuses on a specific aspect of development:

### ğŸ“‹ Rule Categories

1. **ğŸ” [Authentication & Security](.cursor/rules/authentication-security.md)**
   - Clerk authentication patterns
   - Data access security controls
   - API route protection templates

2. **ğŸ—„ï¸ [Database Operations](.cursor/rules/database.md)**
   - Drizzle ORM with user-scoped queries
   - Service layer patterns
   - Type safety requirements

3. **ğŸ›¡ï¸ [API Routes & Data Access](.cursor/rules/api-routes.md)**
   - Secure API route templates
   - Input validation schemas
   - Error handling patterns

4. **ğŸ¨ [Components & UI](.cursor/rules/components-ui.md)**
   - Authentication-aware components
   - Form patterns with validation
   - Accessibility guidelines

5. **ğŸ“ [Code Organization](.cursor/rules/code-organization.md)**
   - Project structure standards
   - Service layer organization
   - Development workflow

### ğŸ”— Quick Access
- **Full Documentation**: [.cursor/rules/README.md](.cursor/rules/README.md)
- **All Rules**: See `.cursor/rules/` directory

## âš¡ Quick Reference

### Required Server Component Pattern (Data Fetching)
```typescript
// app/dashboard/page.tsx
import { auth } from '@clerk/nextjs/server';

export default async function DashboardPage() {
  const { userId } = await auth();
  if (!userId) redirect('/sign-in');
  
  const decks = await deckService.getUserDecks(userId);
  return <DeckList decks={decks} />;
}
```

### Required Server Action Pattern (Mutations)
```typescript
// lib/actions/deck-actions.ts
'use server';
import { auth } from '@clerk/nextjs/server';
import { z } from 'zod';

const createDeckSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().optional(),
});

export async function createDeckAction(input: z.infer<typeof createDeckSchema>) {
  const { userId } = await auth();
  if (!userId) throw new Error('Unauthorized');
  
  const validatedData = createDeckSchema.parse(input);
  return await deckService.createDeck(userId, validatedData);
}
```

### Required Database Pattern
```typescript
// âœ… ALWAYS filter by authenticated user
const userDecks = await db
  .select()
  .from(decksTable)
  .where(eq(decksTable.userId, userId));

// âŒ NEVER query without user context
const allDecks = await db.select().from(decksTable); // FORBIDDEN
```

### Current Schema
- `decksTable`: (id, userId, name, description, createdAt, updatedAt)
- `cardsTable`: (id, deckId, front, back, createdAt, updatedAt)

## ğŸ›¡ï¸ Security Checklist

Every implementation MUST:
- [ ] Authenticate user with Clerk
- [ ] Use server components for data fetching
- [ ] Use server actions for mutations
- [ ] Validate all inputs with Zod schemas
- [ ] Scope all database queries to authenticated userId
- [ ] Never expose other users' data
- [ ] Handle errors without leaking sensitive info

## ğŸš« Prohibited Practices

- âŒ Trusting client-provided user IDs
- âŒ Database queries without userId filtering
- âŒ Bypassing authentication checks
- âŒ Raw SQL or other ORMs (use Drizzle only)
- âŒ Exposing sensitive information in errors
- âŒ Client-side data fetching (use server components)
- âŒ FormData types in server actions (use typed parameters)
- âŒ Unvalidated inputs to server actions (use Zod)
- âŒ Direct API routes for mutations (use server actions)

---

**For detailed implementation patterns, always reference the specific rule files in `.cursor/rules/`.**
